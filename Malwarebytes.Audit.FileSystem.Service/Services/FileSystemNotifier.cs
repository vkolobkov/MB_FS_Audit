using Malwarebytes.Audit.FileSystem.Service.Model;
using Malwarebytes.Audit.FileSystem.Service.Model.Configuration;
using Malwarebytes.Audit.FileSystem.Service.WinApi;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.Versioning;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;

namespace Malwarebytes.Audit.FileSystem.Service.Services
{
    [SupportedOSPlatform("windows")]
    public class FileSystemNotifier : BackgroundService
    {
        private const string ObjectAccessPolicyName = "Object Access";
        private bool _started = false;
        private bool _disposed = false;
        private readonly ILogger<FileSystemNotifier> _logger;
        private readonly IFSEventStore _eventStore;
        private AuditSettings _auditSettings;
        private readonly IDisposable _settingsTracker;
        private readonly Dictionary<string, FileSystemWatcher> _watchers = new Dictionary<string, FileSystemWatcher>();

        public FileSystemNotifier(ILogger<FileSystemNotifier> logger, IOptionsMonitor<AuditSettings> auditOptions, IFSEventStore eventStore)
        {
            _logger = logger;
            _auditSettings = auditOptions.CurrentValue;
            _eventStore = eventStore;

            _settingsTracker = auditOptions.OnChange<AuditSettings>((newAuditSettings) =>
            {
                _auditSettings = newAuditSettings;
                InvalidateWatchers();
                Configure();
            });
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            ConfigurePolicies();

            _started = true;
            Configure();

            while (!stoppingToken.IsCancellationRequested)
            {
                _logger.LogInformation("Worker running at: {time}", DateTimeOffset.Now);
                await Task.Delay(100000, stoppingToken);
            }
        }

        private void ConfigurePolicies()
        {
            try
            {
                AuditPolicyApi auditPolicyApi = new AuditPolicyApi();
                var policySettings = auditPolicyApi.GetAuditPolicySettings();
                if (policySettings[ObjectAccessPolicyName].HasFlag(AuditPolicySetting.Success))
                    return;
                policySettings[ObjectAccessPolicyName] |= AuditPolicySetting.Success;
                auditPolicyApi.SetAuditPolicySettings(policySettings);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to configure Audit Policies.");
            }
        }

        private void InvalidateWatchers()
        {
            List<string> keysToRemove = new List<string>();
            foreach(KeyValuePair<string, FileSystemWatcher> pair in _watchers)
            {
                if (_auditSettings.Directories.Contains(pair.Key))
                    continue;
                keysToRemove.Add(pair.Key);
            }
            foreach(string directoryToRemove in keysToRemove)
            {
                FileSystemWatcher fsw = _watchers[directoryToRemove];
                if (fsw == null)
                    continue;
                _watchers.Remove(directoryToRemove);
                fsw.Changed -= OnChanged;
                fsw.Created -= OnCreated;
                fsw.Deleted -= OnDeleted;
                fsw.Renamed -= OnRenamed;
                fsw.Error -= OnError;
                fsw.Dispose();
            }
        }

        private void Configure()
        {
            if (!_started) return;

            foreach (var directory in _auditSettings.Directories)
            {
                if (!Directory.Exists(directory))
                    continue;
                DirectoryInfo di = new DirectoryInfo(directory);
                if (_watchers.ContainsKey(di.FullName))
                    continue;

                ConfigureSecurityAudit(di.FullName);

                FileSystemWatcher fsw = new FileSystemWatcher(di.FullName);
                fsw.NotifyFilter = NotifyFilters.Attributes
                    | NotifyFilters.CreationTime
                    | NotifyFilters.DirectoryName
                    | NotifyFilters.FileName
                    | NotifyFilters.LastAccess
                    | NotifyFilters.LastWrite
                    | NotifyFilters.Security
                    | NotifyFilters.Size;
                fsw.Filter = "*.*";
                fsw.IncludeSubdirectories = true;
                fsw.EnableRaisingEvents = true;

                fsw.Changed += OnChanged;
                fsw.Created += OnCreated;
                fsw.Deleted += OnDeleted;
                fsw.Renamed += OnRenamed;
                fsw.Error += OnError;

                _watchers[di.FullName] = fsw;
            }
        }

        private void ConfigureSecurityAudit(string dirFullName)
        {
            IdentityReference everyone = new SecurityIdentifier(WellKnownSidType.WorldSid, null).Translate(typeof(NTAccount));
            DirectoryInfo dirInfo = new DirectoryInfo(dirFullName);
            DirectorySecurity dirSecurity = dirInfo.GetAccessControl();
            FileSystemAuditRule dirAuditRule = new FileSystemAuditRule(everyone,
                FileSystemRights.FullControl,
                InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit,
                PropagationFlags.None,
                AuditFlags.Success);
            dirSecurity.AddAuditRule(dirAuditRule);
            dirInfo.SetAccessControl(dirSecurity);
        }

        private void OnError(object sender, ErrorEventArgs e)
        {
            _logger.LogError(e.GetException(), "FileSystemWatcher failed with error");
        }

        private void OnRenamed(object sender, RenamedEventArgs e)
        {
            FSActionDetails fsActionDetails = new FSActionDetails()
            {
                ChangeType = e.ChangeType,
                CreatedAt = DateTime.UtcNow,
                FullPath = e.FullPath,
                OldFullPath = e.OldFullPath,
                Name = e.Name
            };
            _eventStore.Enqueue(fsActionDetails);
        }

        private void OnDeleted(object sender, FileSystemEventArgs e)
        {
            FSActionDetails fsActionDetails = new FSActionDetails()
            {
                ChangeType = e.ChangeType,
                CreatedAt = DateTime.UtcNow,
                FullPath = e.FullPath,
                Name = e.Name
            };
            _eventStore.Enqueue(fsActionDetails);
        }

        private void OnCreated(object sender, FileSystemEventArgs e)
        {
            FSActionDetails fsActionDetails = new FSActionDetails()
            {
                ChangeType = e.ChangeType,
                CreatedAt = DateTime.UtcNow,
                FullPath = e.FullPath,
                Name = e.Name
            };
            _eventStore.Enqueue(fsActionDetails);
        }

        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            FSActionDetails fsActionDetails = new FSActionDetails()
            {
                ChangeType = e.ChangeType,
                CreatedAt = DateTime.UtcNow,
                FullPath = e.FullPath,
                Name = e.Name
            };
            _eventStore.Enqueue(fsActionDetails);
        }

        ~FileSystemNotifier() => Dispose(false);

        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    try
                    {
                        foreach (KeyValuePair<string, FileSystemWatcher> pair in _watchers)
                        {
                            FileSystemWatcher fsw = pair.Value;
                            if (fsw == null)
                                continue;
                            fsw.Changed -= OnChanged;
                            fsw.Created -= OnCreated;
                            fsw.Deleted -= OnDeleted;
                            fsw.Renamed -= OnRenamed;
                            fsw.Error -= OnError;
                            fsw.Dispose();
                        }
                        _watchers.Clear();

                        _settingsTracker.Dispose();
                    }
                    finally
                    {
                        base.Dispose();
                    }
                }
                _disposed = true;
            }

        }

        public override void Dispose()
        {
            Dispose(true);
        }

    }
}
